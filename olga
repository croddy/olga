#!/usr/bin/perl -s

use strict;
use vars qw($channel $mynick $data $irc $conn $james);
use lib qw(/home/james/devel/cim/projects/01_olga);
use Net::IRC;
use Text::Wrap qw(fill $columns);
use LWP::Simple;
use XML::RSS;
use XML::Simple;
use JSON::XS;
use Data::Dumper;

require "movie_quotes.pl";
require "movie_trivia.pl";

$columns = 450;

my @spacerobots =
(
 "I am the Pusher robot.",
 "I am the Shover robot.",
 "Pushing will protect you from the terrible secret of space.",
 "Shoving will protect you from the terrible secret of space.",
);

my %bParams = qw(ELLINGTON_BRANCH Ell TEMPLATE_BRANCH MT
  YOUR_NAME Who BRANCH SV);

$channel = $ARGV[0] ? "#$ARGV[0]" : '#all';
$mynick = $ARGV[1];
print "channel: $channel\n";
$irc = new Net::IRC;
$mynick = 'olga' if (!$mynick);
$conn = $irc->newconn(
  Nick => "$mynick",
  Server => 'irc.cmgdigital.com',
  Port => 6667,
  Ircname => 'Whatcha lookin at, bichachi?',
  Username => "$mynick",
  Password => 'xXxXxXxXxXx',
  );

$data->{userhost} = '(james\@.*\.coxinc\.com|James_Hsi\@.*direcpath.com)';
$data->{jsonfile} = "${mynick}_dat.json";
&init_data($conn);

$conn->add_handler(['376', '422'], \&on_connect);
$conn->add_handler('public', \&on_public);
$conn->add_handler('msg', \&on_public);
$conn->add_handler('join', \&on_join);
$conn->add_handler('nick', \&on_nick);
$conn->add_handler('ping', \&on_ping, 2);
$conn->add_global_handler(353, \&on_names);

$irc->start;

sub on_connect {
  my $self = shift;

  print "Attempting to join $channel\n";
  eval { $self->join("$channel"); };
  if ($@) {
    print "$@";
  }

  $data->{stfu}->{$channel} = 0;

  srand($$);
}

sub on_join {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];

  printf "*** %s (%s) has joined channel %s\n",
  $event->nick, $event->userhost, $channel;

  if ($event->userhost =~ m/$data->{userhost}$/i) {
    $self->mode("$channel", "+o", $event->nick);
  }
}

sub on_names {
  my ($self, $event) = @_;
  my (@list) = $event->args ();

  print "names: @list\n";
}

sub on_nick {
  my ($self, $event) = @_;
  my ($channel) = ($event->to)[0];

  if ($event->userhost =~ m/$data->{userhost}$/i) {
    print Dumper($event);
  }
}

sub on_ping {
  my ($self, $event) = @_;

  &update_bugs($self);
  &update_fails($self);
  &update_latest();
  &update_horoscopes();

  &write_data();
}

sub on_public {
  my ($self, $event) = @_;
  my ($nick, $userhost, $arg, $type) =
    ($event->nick, $event->userhost, $event->args, $event->type);
  my $msg = "$nick, ";

  my $to;
  my $channel = ($event->to)[0];
  if ($type eq 'msg') {
    $to = $nick;
  }
  else {
    $to = $channel;
  }

  if (($type eq "msg") && ($userhost !~ m/$data->{userhost}$/i)) {
    print Dumper($event);
  }

  if (($type eq "msg") || ($arg =~ /^$mynick/i)) {
    $arg =~ s/^$mynick\s*[,:]?\s*//;

    if ($arg =~ /^bugcount\s*(.*)/) {
      my $filter = $1;
      my $count;
      if ($filter) {
        $count = scalar(grep {/$filter/i} keys %{$data->{bugs}});
        $filter .= ' ';
      }
      else {
        $count = scalar(keys %{$data->{bugs}});
      }
      $msg .= "\U$filter\EBug count at $count\n";
    }
    elsif ($arg =~ /^(latest|lb)\s+(.*)/) {
        $msg .= $data->{latest}->{lc($2)}
    }
    elsif ($arg =~ /^(lastreset)/) {
        $msg .= $data->{latest}->{'medley-dev-reset'}
    }
    elsif ($arg =~ /^(stock|quote)\s+(.*)/) {
    #   if (($1 eq "quote") && ($2 =~ /jay/i)) {
    #     my @askquotes = @jayquotes;
    #     $msg .= $askquotes[rand(@askquotes)];
    #   }
      for my $line (split(/\n/, &get_stockprice($2))) {
        $self->privmsg($to, $line);
        sleep 1;
      }
      undef $msg;
    }
    elsif ($arg =~ /^(dow|nasdaq|s&p)/i) {
      my %index =
        ( 'dow', '^DJI', 'nasdaq', '^IXIC', 's&p', '^SPX', );
      $msg = &get_stockprice($index{$1});
    }
    elsif ($arg =~ m/^haiku\s*(.*)/i) {
      if ($1) {
        &haiku($self, $to, $1);
      }
      else {
        &compose_poem($self, $to);
      }
    }
    elsif ($arg =~ m/^tanka/i) {
      &compose_poem($self, $to, 1);
    }
    elsif ($arg =~ /^mquote (.+)/) {
      my ($quote, $line);
      my ($title, $pos) = find_title_quotes ($1);
      if ($title && $pos) {
        ($title, $quote) = pick_quote ($title, $pos);
        $msg = "$title:\n" . join(' ', @$quote);
      }
      else {
        $msg = "Sorry, $nick.  I missed that one.\n";
      }
    }
    elsif ($arg =~ /^trivia (.+)/) {
      my ($trivia, $line);
      my ($title, $pos) = find_title_trivia ($1);
      if ($title && $pos) {
        ($title, $trivia) = pick_trivia ($title, $pos);
        $msg = "$title Trivia:\n" . join(' ', @$trivia);
      }
      else {
        $msg = "Sorry, $nick.  No soup for you.\n";
      }
    }
    elsif ($arg =~ /^scope\s*(.*)/i) {
      $msg = $data->{horoscopes}->{lc($1)};
    }
	# elsif ($arg =~ /^countdown\s+(\d+)/) {
	#     if ($1 < 180) {
	# 	sleep $1;
	# 	$msg .= "this is your reminder.";
	#     }
	# }
    elsif ($arg =~ /^websters\s+black\s+crappie/) {
      $msg .= q(you can't even do that, so don't even try.);
    }
    elsif ($arg =~ /^(saurus|roget)\s+(.*)/) {
      $msg .= &saurus($2);
    }
    elsif ($arg =~ /^sniglet(.*)/) {
      $msg .= &get_sniglet($1);
    }
    elsif ($arg =~ /^abuse\s+([^ ]*)/) {
      $msg = "$1, " . &get_abuse();
    }
    # elsif ($arg =~ /^rhetorical(.*)/) {
    #   $msg .= q(because they're stupid...);
    # }
    elsif ($arg =~ /^morse\s+(.*)/) {
      $msg .= &get_morse($1)
    }
    elsif ($arg =~ /^horoscope\s+([^\s]+)/) {
      my $sagscope = "Dear Teeth-Shaking, Glass-Breaking,
                      Rump-Roasting Bun-Toasting Flash of Liquid Lightning: I
                      dreamed you finally revealed your secret identity after
                      all these years--you know, about how you came from the
                      planet Lovemania in order to teach all earthlings how to
                      feel horny for clouds, trees, tigers, and even the ocean
                      itself!  Is my dream true? Please say it is!  Tell me
                      you're really ready to drop your overly respectable pose
                      so that you may spread erotic healing throughout the
                      land!  Dare to become the sublimely lustful worshiper of
                      beauty and truth you were born to be!";

      if ($1 !~ /sagittarius/i) {
        $msg = "$1, you're gonna die";
        $msg .= " . . . twice" if ($1 =~ /gemini/i);
        $msg .= ".";
      }
      else {
        $msg = "Sagittarius: $sagscope";
      }
    }
    elsif ($arg =~ /^forget\s+(.*)/) {
      delete $data->{facts}->{$1};
      $msg .= "baleeted.";
    }
    elsif ($arg =~ /^help/) {
      my @funcs = qw(bugcount stock quote dow nasdaq s&p haiku tanka
                     scope saurus roget sniglet abuse morse
                     horoscope forget latest);
      $msg .= sprintf("Usage: $mynick <%s>", join('|', @funcs));
    }
    # master commands
    elsif ($userhost =~ m/$data->{userhost}$/i) {
      if ($arg =~ /^say (\S+) (.+)/i) {
        $to = $1;
        $msg = $2;
      }
      elsif (($arg =~ /^stfu/i) && ($type eq 'public')) {
        $data->{stfu}->{$channel} = 1;
        $msg = 'Right-o.';
      }
      elsif (($arg =~ /^speak/i) && ($type eq 'public')) {
        $data->{stfu}->{$channel} = 0;
        $msg = 'Zug-zug.';
      }
      elsif ($arg =~ /^join (.*)/) {
        $self->join($1);
        $msg .= "joining $1";
      }
      elsif ($arg =~ /^deop (\S+) (.+)/) {
        $to = $2;
        $self->mode("$2", "-o", $1);
        $msg = 'The Lord giveth and the lord taketh away...';
      }
      elsif ($arg =~ /^op (\S+) (.+)/) {
        $to = $nick;
        $self->mode("$2", "+o", $1);
        $msg .= "op $1 on $2";
      }
      elsif ($arg =~ /^dump\s*(.*)/) {
        if ($1) {
          $to = $nick;
          $msg = Dumper($data->{$1});
        }
        else {
          print Dumper($data);
          undef $msg;
        }
      }
      elsif ($arg =~ /^refresh/) {
        delete $data->{bugs};
        delete $data->{hudson};

        &update_bugs($self, 1);
        &update_fails($self, 1);
        &update_latest();
      }
      elsif ($arg =~ /^jsondump/) {
        &write_data();
        $msg = "Dumped.";
      }
      elsif ($arg =~ /^die/) {
        &write_data();
        exit();
      }
      elsif ($arg =~ /^setdata\s+(\S*)\s+(\S*)/) {
        $data->{$1} = $2;
        $msg = "Updated";
      }
      elsif ($arg =~ /^killdata\s+(\S*)/) {
        delete $data->{$1};
        $msg .= "baleeted.";
      }
    }
    else {
      my (@wit) =
        (
         "PAK CHOOIE UNF",
         "I'll be in my bunk...",
         "hey, how's it goin?",
         "You know what the chain of command is? It's the chain I go get and beat you with 'til ya understand who's in ruttin' command here.",
        );
      push @wit, @spacerobots;
      $msg .= $wit[rand(@wit)] if (rand() < $data->{talkback});
    }
    &fill_output($self, $msg, $to) unless $msg eq "$nick, ";
  }
  elsif ($arg =~ /^(sudo )?(ls( .*)?|pwd|cd( .*)?|rm( .*)?)$/) {
    $msg = "this ain\'t your shell window";
    $self->privmsg($to, "$msg\n")
      unless ($data->{stfu}->{$channel});
  }
  elsif ($arg =~ /^(\:wq)$/) {
    $msg = "this ain\'t your vi";
    $self->privmsg($to, "$msg\n")
      unless ($data->{stfu}->{$channel});
  }
  elsif ($arg =~ /PAK.*UNF/) {
    $msg = $spacerobots[rand(@spacerobots)];
    $self->privmsg($to, "$msg\n")
      unless ($data->{stfu}->{$channel});
  }
  elsif ($arg =~ /pythonpath/i) {
    $msg = "If you're mucking with your PYTHONPATH, you're doing it wrong.";
    $self->privmsg($to,"$msg\n")
      unless ($data->{stfu}->{$channel});
  }
  elsif ($arg =~ m/^You're a towel!/) {
    if ($nick eq "Towelie") {
      $msg = "No, you're a towel!" if (rand() < $data->{towel});
    }
  }
  elsif ($arg =~ m/((CMS[A-Z]+|CHR|GUR|WD|FR|HELPDESK)-[0-9]+)/) {
    my $ticket = $1;
    if ($arg !~ m{browse/$1}) {
      # record recent tickets
      my $time = time();
      if ($time - $data->{recent}->{$ticket}->{time} > 10*60) {
        $data->{recent}->{$ticket}->{time} = time();
        $data->{recent}->{$ticket}->{count} = 1;
      }
      else {
        if ($time - $data->{recent}->{$ticket}->{time} < 20) {
          $data->{recent}->{$ticket}->{count}++;
        }
      }

      # check message type
      if ($data->{recent}->{$ticket}->{count} > 4) {
        undef $msg;
      }
      elsif ($data->{recent}->{$ticket}->{count} > 3) {
        $msg = "Seriously, dude. That's annoying. Quit it.";
      }
      elsif ($data->{recent}->{$ticket}->{count} > 2) {
        $msg = "Dude, quit it.";
      }
      else {
        $msg =
          "$nick may be talking about: " .
          "http://jira.ddtc.cmgdigital.com/browse/$1";
      }

      # output message
      if ($msg) {
        $self->privmsg($to, "$msg\n")
          unless ($data->{stfu}->{$channel});
      }
    }
  }
  elsif ($arg =~ m/^((\S*?)\s+(is|are|=)\s+([^;]*))$/i) {
    my ($sentence, $subject, $predicate) = ($1, $2, $4);
    if ($predicate =~ m/\`/) {
      $self->privmsg($to, "You can't even do that, so don't even try.");
    }
    elsif ($predicate =~ m/^<reply>\s*/) {
      $predicate =~ s/^<reply>\s*//;
      $data->{facts}->{lc($subject)} = "$predicate ($nick)";
    }
    else {
      $data->{facts}->{lc($subject)} = "$sentence ($nick)"
        unless $data->{facts}->{lc($subject)};
    }
  }
  elsif ($arg =~ m/^(.*)\?$/) {
    $self->privmsg($to, $data->{facts}->{lc($1)});
  }
}

sub fill_output {
  my ($self, $msg, $to) = @_;

  # kill existing lines
  $msg =~ s/\n/ /g;

  my @result = split(/\n/, fill('', '', $msg));
  for my $line (@result) {
    $self->privmsg($to, $line);
    sleep 1;
  }
}

sub haiku {
  my ($conn, $to, $args) = @_;

  my $usage = "Usage: haiku add (fives|sevens) <phrase>\n";


  if ($args) {
    $args =~ m/^(\S*)\s+(\S*)\s+(.*)$/;
    my ($proc, $type, $phrase) = ($1, $2, $3);

    if (($proc !~ m/^(add|remove)/i) || ($type !~ m/^(five|seven)s/i)) {
      $conn->privmsg($to, $usage);
      return;
    }
    if ($proc =~ m/^add$/i) {
      push @{$data->{haiku}->{lc($type)}}, $phrase;
      $conn->privmsg($to, "Added.\n");
    }
    else {
      @{$data->{haiku}->{lc($type)}} =
        grep {!/$phrase/} @{$data->{haiku}->{lc($type)}};
      $conn->privmsg($to, "Removed.\n");
    }
  }
}

sub compose_poem {
  my ($conn, $to, $type) = @_;

  my @fives;
  my @sevens;
  push @fives, @{$data->{haiku}->{fives}};
  push @sevens, @{$data->{haiku}->{sevens}};

  my $five = $fives[rand(@fives)];
  @fives = grep {!/$five/} @fives;

  my $seven1 = $sevens[rand(@sevens)];
  @sevens = grep {!/$seven1/} @sevens;
  my $seven2 = $sevens[rand(@sevens)];
  @sevens = grep {!/$seven2/} @sevens;

  $conn->privmsg($to, $five);
  $conn->privmsg($to, $seven1);
  $conn->privmsg($to, $fives[rand(@fives)]);
  $conn->privmsg($to, $seven2) if ($type);
  $conn->privmsg($to, $sevens[rand(@sevens)]) if ($type);
}

sub saurus {
  my @args = @_;

  my %rtypes = qw( sim similar syn synonyms ant antonyms usr user-submitted );

  my $apikey = q(ab4c2716b98b1c76f4b889014214dadb);
  my $url = sprintf(qq(http://words.bighugelabs.com/api/2/%s/%s/json),
                    $apikey, $args[0]
    );

  my $hash = decode_json(get($url));

  my $result = "$args[0]: ";
  for my $key (keys %$hash) {
    next if $args[1] && $key ne $args[1];

    for my $type (keys %{$hash->{$key}}) {
      $result .= "* $rtypes{$type} ($key) - " .
        join(', ', @{$hash->{$key}->{$type}}) . "\n";
    }
  }
  return $result;
}

sub get_stockprice {
  my ($args) = @_;

  my $stocks =
    get(sprintf('http://download.finance.yahoo.com/d/quotes.csv?s=%s&f=snl1c1',
                join('+', split(/\s/, $args)))
    );

  $stocks =~ s/,/\t/g;
  $stocks =~ s/"//g;

  return $stocks;

  print $stocks;

}

sub get_morse {
  my $inarg = shift;
  my ($result, $trans, $splitter);

  my %alpha2morse =
    ( 'a', '.-', 'b', '-...', 'c', '-.-.', 'd', '-..', 'e', '.', 'f',
      '..-.', 'g', '--.', 'h', '....', 'i', '..', 'j', '.---', 'k',
      '-.-', 'l', '.-..', 'm', '--', 'n', '-.', 'o', '---', 'p',
      '.--.', 'q', '--.-', 'r', '.-.', 's', '...', 't', '-', 'u',
      '..-', 'v', '...-', 'w', '.--', 'x', '-..-', 'y', '-.--', 'z',
      '--..', '1', '.----', '2', '..---', '3', '...--', '4', '....-',
      '5', '.....', '6', '-....', '7', '--...', '8', '---..', '9',
      '----.', '0', '-----', "\n", "\n", ' ', ' ',);

  my %morse2alpha = reverse %alpha2morse;

  if ($inarg =~ /[A-Za-z0-9]/) {
    $inarg = lc($inarg);
    $trans = \%alpha2morse;
    $splitter = "";
  }
  else {
    $inarg =~ s/\_/\-/g;
    $trans = \%morse2alpha;
    $splitter = " ";
  }
  my @morsey = split (/$splitter/, $inarg);

  foreach my $elem (@morsey) {
    $result .= $trans->{"$elem"}," ";
  }

  return $result;
}

sub update_horoscopes {
  my $time = time();
  if ($time - $data->{horoscopes}->{update} > 86400) {
    my $page =
      get(q(http://www.freewillastrology.com/horoscopes/printer-friendly.html));

    my $cursign;
    for my $line (split(/\n/, $page)) {
      next unless ($line =~ m/div class="body-bold">(\S*)\s+\(/i ..
                   $line =~ m%<p>%i);
      if ($1) {
        $cursign = lc($1);
        delete $data->{horoscopes}->{$cursign};
      }
      $line =~ s/<[^>]*>//g;
      $line =~ s/\)/\) /g;

      $data->{horoscopes}->{$cursign} .= $line;
    }
    $data->{horoscopes}->{update} = time();
  }
}

sub get_sniglet {
  my $wordlet = shift;
  my ($sniglets) = ("/home/james/devel/cim/projects/01_olga/data/sniglets.txt");
  my ($result);

  $wordlet =~ s/\s*//g;

  open(SNG,"<$sniglets") || warn "can't open $sniglets: $!";
  if ($wordlet) {
    while (<SNG>) {
      if (/^$wordlet/i) {
        chomp($_);
        $result = $_;
        last;
      }
    }
  }
  else {
    rand($.) < 1 && ($result = $_) while <SNG>;
  }
  close SNG;
  $result = "I dunno..." if (!$result);
  return $result;
}

sub get_abuse {
  my @styles = (0, 3);
  my $style = $styles[rand(@styles)];
  my $url = sprintf('http://www.webinsult.com/index.php?style=%s',
                    $style);

  my ($insult) = grep {/id="insult"/} split(/\n/,get($url));
  $insult =~ s/<[^>]*>//g;
  return lcfirst($insult);
}

sub update_bugs {
  my ($self, $init) = @_;

  my $bugs_rss = 'http://jira.ddtc.cmgdigital.com/sr/jira.issueviews:searchrequest-xml/10204/SearchRequest-10204.xml';

  my $rss = XML::RSS->new;
  $rss->parse(get($bugs_rss));

  for my $item (@{$rss->{'items'}}) {
    unless ($data->{bugs}->{$item->{key}}) {
      $data->{bugs}->{$item->{key}} = $item->{title};

      unless ($init) {
        my $id = $item->{key};
        $id =~ s/[\[\]]//g;
        my $url = sprintf("http://jira.ddtc.cmgdigital.com/browse/%s",
                          $id);
          $self->privmsg($channel,
                         sprintf("*** New bug! %s %s\n",
                                 $item->{title}, $url)
                         );
      }
    }
  }
}

sub update_fails {
  my ($self, $init) = @_;

  my $feed = XMLin(
    get('http://vcs.ddtc.cmgdigital.com:9191/hudson/rssFailed')
    );

  for my $key (keys %{$feed->{entry}}) {
    my $entry = $feed->{entry}->{$key};

    unless ($data->{hudson}->{$entry->{title}}) {
      $data->{hudson}->{$entry->{title}} = $entry->{link}->{href};
      unless ($init) {
        my $params = get($entry->{link}->{href});
        $params =~ s/^.*buildWithParameters\?([^"]*)".*$/$1/s;

        $params = join(' ',
                       map { my ($k, $v) = split(/=/,$_); "$bParams{$k}: $v" }
                       split(/\&amp;/, $params));

        $self->privmsg($channel,
                       "$entry->{title}: $entry->{link}->{href} $params\n")
      }
    }
  }
}

sub update_latest {
  my @urls = qw(view/Developer%20View/rssLatest rssLatest);
  my $dtf = DateTime::Format::W3CDTF->new;

  for my $url (@urls) {
    my $feed =
      XMLin(
        get(sprintf(
              'http://vcs.ddtc.cmgdigital.com:9191/hudson/%s',
              $url,
            )));

    for my $key (keys %{$feed->{entry}}) {
      my $entry = $feed->{entry}->{$key};

      my $latestkey = lc($entry->{title});
      $latestkey =~ s/^(\S*)\s+.*/$1/;

      my $dt = $dtf->parse_datetime($entry->{published})
        ->set_time_zone('local');

      $data->{latest}->{$latestkey} = sprintf('%s %s %s',
                                              $dt->strftime('%F %T'),
                                              $entry->{title},
                                              $entry->{link}->{href},
        );
    }
  }
}

sub init_data {
  my ($conn) = @_;

  if (!-e $data->{jsonfile}) {
    &update_bugs($conn, 1);
    &update_fails($conn, 1);
    &update_latest();
    &update_horoscopes();

    &write_data();
  }

  open(FILE,"<$data->{jsonfile}") || warn "Can't open $data->{jsonfile}: $!";
  my $json = do { local $/; <FILE>; };
  close(FILE);

  $data = decode_json($json);
}

sub write_data {
  my $json = encode_json($data);

  open(FILE,">$data->{jsonfile}") || warn "Can't open $data->{jsonfile}: $!";
  print FILE $json;
  close(FILE);
}
